[{"title":"使用智能指针管理C++对象生命周期","path":"/2024/10/12/使用智能指针管理对象生命周期/","content":"在C++多线程环境下，对象的生命周期管理一直是工程实践中的一大挑战。一旦处理不当，极易引发内存泄漏或程序崩溃，给项目稳定性带来巨大隐患。 建议使用C++智能指针管理对象生命周期，避免直接使用裸指针。智能指针能够自动处理内存管理，提高了代码的安全性和可靠性，同时也减少了手动管理内存的负担，提升了程序的健壮性。 典型场景一个对象需要委派给工作线程（worker thread）来异步执行某项任务。在此期间，关键在于确保该对象在其生命周期内保持有效，避免在工作线程还在访问它的过程中已经析构。因为这将触发未定义行为，导致程序崩溃。 在设计异步处理逻辑时，一个常见且高效的实践是将该对象的weak_ptr作为参数传递给异步任务的闭包。在工作线程实际执行任务前，通过weak_ptr调用lock函数，可以安全地检查并尝试升级为shared_ptr，确保对象依然存活，有效避免了因为对象提前析构而导致的访问悬挂指针问题。 一、继承enable_shared_from_this通过继承自enable_shared_from_this，我们的类能够在成员函数内部使用shared_from_this()方法，进而获得指向当前对象的共享指针。 12345678class Myclass : public std::enable_shared_from_this&lt;MyClass&gt; &#123;public:\tMyClass() = default;\tvoid process(); private:\tvoid process_w();&#125;; 123456789101112131415void MyClass::process () &#123;\t// get worker thread from thread pool\tauto workerThread = ThreadPool::Instance()-&gt;Get();\tstd::weak_ptr&lt;MyClass&gt; weakThis = shared_from_this();\tworkerThread-&gt;post([weakThis]&#123; // lock the weak pointer to check if &#x27;this&#x27; still exists auto sharedThis = weakThis.lock(); if (!sharedThis) return; sharedThis-&gt;process_w();\t&#125;);&#125;void MyClass::process_w() &#123;\t// process in worker thread...&#125; 二、构造工厂方法如果不想引入继承，我们可以选择设计一个工厂方法Create来实例化对象，此方法在生成对象实体的同时为成员变量mWeakThis赋值。为了进一步封装和确保安全，我们将MyClass的构造函数设为私有。 12345678910class Myclass : public std::enable_shared_from_this&lt;MyClass&gt; &#123;public:\tstatic std::shared_ptr&lt;MyClass&gt; Create();\tvoid process(); private: MyClass() = default;\tvoid process_w(); std::weak_ptr&lt;MyClass&gt; mWeakThis;&#125;; 1234567891011121314151617181920std::shared_ptr&lt;MyClass&gt; MyClass::Create() &#123;\tauto instance = std::shared_ptr&lt;MyClass&gt;(new MyClass());\tinstance-&gt;mWeakThis = instance;\treturn instance;&#125;void MyClass::process () &#123;\t// get worker thread from thread pool\tauto workerThread = ThreadPool::Instance()-&gt;Get();\tworkerThread-&gt;post([mWeakThis] &#123; // lock the weak pointer to check if &#x27;this&#x27; still exists auto sharedThis = mWeakThis.lock(); if (!sharedThis) return; sharedThis-&gt;process_w();\t&#125;);&#125;void MyClass::process_w() &#123;\t// process in worker thread...&#125;","tags":["c++"],"categories":["tech"]},{"title":"std::sort使用不规范导致Crash问题","path":"/2024/06/16/sort使用不规范导致Crash问题/","content":"问题排查最近在使用std::sort进行排序的时候遇到一个crash问题，一开始摸不着头脑，花了一番功夫才找到原因。背景是音视频通信的媒体服务端在和客户端建立媒体通道时，往往会有多条连接作为主备连接，应对不同网络情况，例如同时有5G、WIFI等多路连接。这些连接一般都是由客户端通过发送STUN协议的UDP包发起的。当客户端建立的连接数超过限制时，服务端需要枝剪多余连接，枝剪的逻辑需要通过对比连接质量等一系列条件来排序决定。C++标准库已经为我们实现性能优异的std:sort，通常也没人会去挑战STL，这里我也直接就用了。代码片段如下： 12345678910void P2PTransportChannel::PruneConnections2() &#123; std::map&lt;rtc_base::IPAddress, std::vector&lt;Connection*&gt;&gt; conns_map; //... insert map for (auto pair : conns_map) &#123; // sort connections std::sort(pair.second.begin(), pair.second.end(), [this](Connection* a, Connection* b) &#123; return CompareConnectionCandidates(a, b) &gt;= 0; &#125;); &#125;&#125; 这里sort传入一个闭包，闭包里调用CompareConnectionCandidates方法比较两条连接的优先级（因为两条连接可能优先级相等，所以用了**&gt;&#x3D;**，这也为后面的crash埋下了伏笔）。代码乍一看好像没啥问题，上线前自测和QA测试也都正常。然而版本上线后，线上却出现了多例crash，coredump在了比较方法中，而且有个特点是connection连接数都比较多；从crash堆栈看到参与比较的两个Connection指针a&#x3D;0x87a804feff3e1602，b&#x3D;0x4bc4a00，这里a的指针异常大： 123456#0 0×00007f849b8cbbf1 in ice::P2PTransportChannel::CompareCandidatePairNetworks (ice::Connection const*, ice::Connection const*, rtc_base::optional&lt;rtc_base::AdapterType&gt;) const (this=0xd0c1400, a=0×87a804feffe1602, b=0x4bc4a00, network_pr eference=...) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1629#1 0x00007f849b8cbdab in ice::P2PTransportChannel::CompareConnectionCandidates (ice::Connection const*, ice::Connection const*) const (this=&lt;optimized cut &gt;, a=0x87a804feff3e1602, b=0x4bc4a00) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1731#2 0x00007f849b8cc0df in ice::P2PTransportChannel::&lt;lambda(ice::Connection *, ice::Connection*)&gt;::operator() (b=&lt;optimized out&gt;, a=&lt;optimized out&gt;, closure=&lt;synthetic pointer&gt;) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1996#3 0x007849b8ccodf in _gnu_cxx_opsTter_cop_itercdin_ice:PPTransportChannel::PruneConnections2()::&lt;lambda(ice::Connection*, ice::Connection*)&gt;&gt;::operator()&lt;_gnu_cxx::_normal_iteratorșice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;,_gnu_cxx::_normal_iterator&lt;ice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;&gt;(it2=0x4bc4a00, _it1=..., this=&lt;synthetic pointer&gt;) at /opt/rh/devtoolset-7/root/usr/include/c++/7/bits/predefined_ops.h:143#4 0×00007f849b8ccodf in std::_unguarded_partitions_gnu_cxx::_normal_iterator&lt;ice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;,_gnu_cxx::_ops::_Iter_comp_iter&lt;ice::P2PTransportChannel::PruneConnections2()::&lt;lambda(ice::Connection*, ice::Connection*)&gt;&gt;&gt;(_comp=..., _pivot=0x4bc4a00, _last=0×87a804feff3e1602, _first=0x87a804feff3e1602) at /opt/rh/devtoolset-7/root/usr/include/c++/7/bits/stl_algo.h:1902normal 为了进一步确认，继续通过反汇编查看crash附近代码执行情况。可以看到崩溃行所在地方是从rsi访存写入rax寄存器，很可能是bad access了： 12 0x00007f849b8cbbf0 &lt;+0&gt;: push %rbp=&gt; 0x00007f849b8cbbf1 &lt;+1&gt;: mov 0x150 (%rsi),%rax 继续查看内部寄存器状态： 12345678910info registerrax 0×0 0rbx 0x5f8cd78 100191608rcx 0×7f849e4b2db8 140207568137656rdx 0×4bc4a00 79448576rsi 0×87a804feff3e1602 -8671675589251426814rdi 0×d0c1400 218895360rbp 0×7f849e4b2de0 0×7f849e4b2de0 rsp 0×7f849e4b2da0 0×7f849e4b2da0 果然，rsi寄存器存放的Connection指针地址异常了。但是这里我们用的标准库进行遍历的，vector对象也在栈上，难道vector内部成员被篡改了？继续查看vector对象，一共17个成员，Connection指针地址也没有问题。难道是vector::end()返回的地址有问题？ 12p pair.second $3 = std::vector of length 17, capacity 17=&#123;0×4bc4a00, 0xfb5de00, 0xf43c400, 0xf43a0, 0xef7400, xf43be00, 0xf3b000, xf43000, xf3bde00,0x1b800, xef73, fb5e400, 0xf3bf600, 0xf3bc600, 0x11b26000, 0xe18e000, 0x11b27e00&#125; 继续查看vector内部结构题_M_impl。其中_M_start指向容器中第一个元素的指针，_M_finish指向容器最后一个有效元素的下一个位置的指针，end()方法返回的就是_M_finish。 12p pair.second._M_impl$2=&#123;&lt;std::allocator&lt;ice::Connection*&gt;&gt;=&#123;&lt;_gnu_cxx::new_allocator&lt;ice::Connection*&gt;&gt;=&#123;&lt;No data fields&gt;&#125;, &lt;No data fields&gt;&#125;, M_start =0x5f8ccf0, _M_finish =0x5f8cd78, _M_end_of_storage = 0x5f8cd78&#125; M_finish &#x3D; 0x5f8cd78，这个地址看起来也没问题。既然拿到了内存地址，我们可以进一步分析下里面存的到底是什么： 1234567891011121314151617x /8xg 0x5f8ccf00x5f8ccf0: 0x0000000004bc4a00 0x000000000fb5de000x5f8cd00: 0x000000000f43c400 0x000000000f43ac000x5f8cd10: 0x000000000ef74a00 0x000000000f43be000x5f8cd20: 0x000000000f3bc000 0X000000000f43a000`x /8xg 0x5f8cd300x5f8cd30: 0x000000000f3bde00 0x0000000011b278000x5f8cd40: 0x000000000ef73800 0x000000000fb5e4000x5f8cd50: 0x000000000f3bf600 0x000000000f3bc6000x5f8cd60: 0x0000000011626000 0x000000000e18e000x /8xg 0x5f8cd700x5f8cd70: 0x0000000011b27e00 0x87a804feff3e16020x5f8cd80: 0x0000000005f8ce10 0x00000000000000000x5f8cd90: 0x0000000100000005 0x00000000000000010x5f8cda0: 0x0000000000000000 0x0000000100000005 这里我们用x&#x2F;8xg 查看内存地址。8代表要显示的内存单元数量，x表示16进制，g表示读取8字可以看到异常值0x87a804feff3e1602在内存地址0x5f8cd78处。这个地址对应_M_finish，是结束的地方，按道理sort排序不可能会访问到这个地址。但是出错的堆栈又实实在在指向了这个地址，一时间没有了思路。 std::sort实现没办法，只能尝试从源码入手，看看能不能有线索。通过分析代码和查阅资料，了解到gcc7的sort实现采用了混合排序，包含了插入排序、快速排序、桶排序三种排序算法，目的是为了综合各种排序算法的优点： 在数据量很大时采用正常的快速排序，此时效率为O（logN）。 一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O（N）。 在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O（N IogN），但这又比一开始使用堆排序好。 实现代码如下： 1234567891011template&lt;typename _RandomAccessIterator, typename _Compare&gt;inline void_sort(_RandomAccessIterator _first, _RandomAccessIterator _last, _Compare _comp)&#123; if (_first!= _last) &#123; std::_introsort_loop(_first, _last, _comp); // 内省式排序 std::lg(_last - _first) * 2; // 计算复杂度 std::_final_insertion_sort(_first, _last, _comp); // 插入排序 &#125;&#125; 这里是一个函数模版，包含了两个调用，std：introsort_loop是排序算法主体，std::final_insertion_sort则是插入排序；先来看__introsort_loop： 123456789101112131415161718template&lt;typename _RandomAccessIterator, typename _Size, typename _Compare&gt;void_introsort_loop(_RandomAccessIterator _first, _RandomAccessIterator _last, _Size _depth_limit, _Compare _comp)&#123; while (_last - _first &gt; int(_S_threshold))）// 数量大于_S_threshold（16），使用快速排序 &#123; if (_depth_limit == 0) &#123; std::_partial_sort(_first, _last, _last, _comp);// 深度&gt;0，使用桶排序 return; &#125; --_depth_limit; _RandomAccessIterator _cut = std::_unguarded_partition_pivot(_first, _last, _comp); _last = _cut; std::_introsort_loop(_cut, _last, _depth_limit, _comp); &#125;&#125; 注意只有当vector的数量超过_S_threshold（16）时，才会导致进入快速排序；否则，直接跳出循环（执行final_insertion_sort插入排序）。快速排序在while循坏体中，这里有一定的技巧性，调用unguarded_partition_pivot的返回值cut是pivot右半部分，之后再pivot左半部分继续调用introsort_loop，这样做可以减少函数调用次数。接下来我们继续查看__unguarded_partition_pivot主体函数： 12345678template&lt;typename _RandomAccessIterator, typename _Compare&gt;inline _RandomAccessIterator_unguarded_partition_pivot(_RandomAccessIterator _first, _RandomAccessIterator _last, _Compare _comp)&#123; _RandomAccessIterator _mid = _first + (_last - _first) / 2; std::_move_median_to_first(_first, _first + 1, _mid, _last - 1, _comp); return std::_unguarded_partition(_first + 1, _last, _first, _comp);&#125; 主体分为两个方法，move_median_to_first的作用是从首部+1、尾部和中部三个元素的取中值作为pivot，避免可能出现快速排序的复杂度最差情况O（N？）。注意这里会调用comp比较函数进行比较和swap操作，把中间值交互到首部： 1234567891011121314151617181920template&lt;typename _Iterator, typename _Compare&gt;void_move_median_to_first(_Iterator _result, _Iterator _a, _Iterator _b, _Iterator _c, _Compare _comp)&#123; if (_comp(_a, _b)) &#123; if (_comp(_b, _c)) std::iter_swap(_result, _b); else if (_comp(_a, _c)) std::iter_swap(_result, _c); else std::iter_swap(_result, _a); &#125; else if (_comp(_a, _c)) std::iter_swap(_result, _c); else if (_comp(_b, _c)) std::iter_swap(_result, _b); else std::iter_swap(_result, _b);&#125; __unguarded_partition方法就是我们平常所使用的快速排序主体部分： 123456789101112131415template&lt;typename _RandomAccessIterator, typename _Compare&gt;_RandomAccessIterator _unguarded_partition(_RandomAccessIterator _first, _RandomAccessIterator _last, _RandomAccessIterator _pivot, _Compare _comp)&#123; while (true) &#123; while (_comp(_first, _pivot)) ++_first; while (_comp(_pivot, _last)) --_last; if (!(_first &lt; _last)) return _first; std::iter_swap(_first, _last); ++_first; &#125;&#125; 这里不多做解释，《STL源码剖析》给出了两个非常直观的示意图： 分割示例一 分割示例二 方法名unguarded和代码里的while循环引起了我的警觉，这个函数没有对first和last作边界检查，而是以两个指针交错作为中止条件，节约了比较运算的开支。可以这么做的理由是因为，选择是首尾中间位置三个值的中间值作为pivot，因此一定会在超出此有效区域之前中止指针的移动（前提是comp条件不能相等）。这里_comp(_first, _pivot)如果是true，first会一直循环递增。我们的业务逻辑中，比较元素Connection是可能相等的。这里极有可能是first累加越界了，其地址也能和崩溃的地址对上。 如果是这个原因的话，我们就好验证了。写一段测试代码，放入大于_S_threshold（16）个相同元素，看看会不会崩溃。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;struct Connection &#123; int val = 0;&#125;;bool compare(Connection* a, Connection* b) &#123; return a-&gt;val &gt;= b-&gt;val;&#125;int main() &#123; std::map&lt;int, std::vector&lt;Connection*&gt;&gt; conn_map; for (int i = 0; i &lt; 17; i++) &#123; Connection* c = new Connection&#123;1&#125;; conn_map[1].push_back(c); &#125; for (auto&amp; pair : conn_map) &#123; std::sort(pair.second.begin(), pair.second.end(), compare); &#125; std::cout &lt;&lt; &quot;ok:&quot; &lt;&lt; conn_map[1].size() &lt;&lt; std::endl; return 0;&#125; 使用gcc7编译运行，果然出现崩溃了： 12$./a. out2 Segmentation fault (core dumped) 而将17改为16之后，结果就不崩溃了： 12$./a.out2 ok: 16 到这里，问题原因算是找到了。这也解释了为什么自测和QA难以发现，只有线上连接数多的时候才出现。回过头来查阅文档，上面写的很明白，sort的comp函数必须严格满足严格弱序（strict weak order）： 1234Establishes strict weak ordering relation with the following properties:- For all a, comp(a, a) == false.- If comp(a, b) == true then comp(b, a) == false.- if comp(a, b) == true and comp(b, c) == true then comp(a, c) == true. 看来还是使用的姿势不对，修复就好办了，我们把判断条件中的&#x3D;去掉，这下也正常了： 12$./a.out2 0k:17 总结 std::sort实现混合了多种排序算法，当元素数量超过16个，会使用快速排序，不会进行边界检查； std::sort的comp函数必须严格满足严格弱序，如果比较元素相等，可能会导致crash问题； 如果比较元素可能相等，想要结果保持稳定，使用std::stable_sort代替std::sort； 参考：https://feihu.me/blog/2014/sgi-std-sort/","tags":["c++"],"categories":["tech"]},{"title":"Hello, World!","path":"/2023/05/28/Hello, World!/","content":"Welcome to my Blog."},{"title":"404 Not Found：该页无法显示","path":"//404.html","content":""},{"title":"关于","path":"/about/index.html","content":"程序员"}]
[{"title":"服务端基于libMesa实现离屏渲染","path":"/2025/01/18/code/服务端基于libMesa实现离屏渲染/","content":"OpenGL是一种跨平台的图形渲染API，主要用于2D和3D图形的渲染。OpenGL实现通常由GPU厂商提供，使得程序可以不关心硬件实现直接与GPU做交互。一般情况下图形渲染在客户端进行，因为大部分渲染目标都是屏幕窗口。而不同操作系统的图形窗口系统实现千差万别，所以又有了EGL（Embedded-System Graphics Library） 接口，用于管理图形上下文、Surface，作为OpenGL与原始窗口系统之间的桥梁。 服务端渲染是相对小众的需求，主要场景有云渲染、媒体处理等。服务端渲染有一个问题是我们的服务通常部署在ECS或K8s上，不会配置GPU，也没有GUI界面，软硬件环境都不具备。要解决这个问题，我们可以借助开源的图形库libMesa。 OSMesa软件渲染OSMesa (Off-Screen Mesa) 是libMesa的一部分。可以用于在没有窗口系统支持的情况下进衣赖于GPU进行渲染。OSMesa的使用也很简单，首先安装依赖： 1yum install -y mesa-libOSMesa-devel mesa-libGL-devel mesa-libEGL-devel 接下来是常规的创建GL上下文，这里需要引入&lt;GL&#x2F;osmesa.h&gt;头文件，使用其提供系列函数实现GL上下文管理，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;GL/osmesa.h&gt;#include &lt;GL/gl. h&gt;int main()&#123; // 定义窗口宽度和高度 const int width = 800; const int height = 600; // 创建OSMesa上下文 OSMesaContext ctx = 0SMesaCreateContextExt(OSMESA_RGBA, 16, 0, 0, NULL); if (!ctx) &#123; fprintf(stderr, &quot;OSMesaCreateContext failed &quot;); return 1; &#125; // 创建一个缓冲区 void *buffer = malloc(width * height * 4); if (!buffer) &#123; printf(stderr, &quot;Buffer allocation failed &quot;); OSMesaDestroyContext(ctx); return 1; &#125; // 创建一个缓冲区 void *buffer = malloc(width * height * 4); if (!buffer) &#123; fprintf(stderr, &quot;Buffer allocation failed &quot;); OSMesaDestroyContext(ctx); return 1; &#125; // 绑定上下文并将缓冲区绑定到上下文 OSMesaMakeCurrent(ctx, buffer, GL_UNSIGNED_BYTE, width, height); // 清除颜色缓冲区为红色 glClearColor(1.0, 0.0, 0.0, 1.0); gLClear(GL_COLOR_BUFFER_BIT); // 将绘制结果保存到文件 FILE *f = fopen(&quot;output. rgba&quot;, &quot;wb&quot;); if (f) &#123; fwrite(buffer, width * height * 4, 1, f); fclose(f); printf(&quot;Image saved to output.rgba &quot;); &#125; else &#123; fprintf(stderr, &quot;Failed to open file for writing &quot;); &#125; // 清理 OSMesaMakeCurrent((OSMesaContext) nullptr, nullptr, GL_UNSIGNED_BYTE, 0, 0); free(buffer); OSMesaDestroyContext(ctx); return 0;&#125; 这里我们创建了一块内存作为渲染缓冲区，渲染结果直接可以通过内存获取。当然，使用glReadPixels 读取结果也是一样的。 DRM硬件加速如果你的服务部署在本地物理机并配置有显卡，或是配置了带GPU的ECS机器，那可以用DRM做硬件加速。DRM（Direct Rendering Manager）是Linux内核的一部分，用于管理图形显示的硬件加速以及图形上下文的切换。它的优点是可以不依赖图形窗口系统，直接与GPU通信，提高渲染性能。这个方案我们项目里没有实际应用，相关实现可以参考libMesa提供的demo：https://gitlab.freedesktop.org/mesa/demos/-/blob/main/src/egl/opengl/eglkms.c","tags":["AV","Linux"],"categories":["code"]},{"title":"使用智能指针管理对象生命周期","path":"/2024/10/12/code/使用智能指针管理对象生命周期/","content":"在C++多线程环境下，对象的生命周期管理一直是工程实践中的一大挑战。一旦处理不当，极易引发内存泄漏或程序崩溃，给项目稳定性带来巨大隐患。 建议使用C++智能指针管理对象生命周期，避免直接使用裸指针。智能指针能够自动处理内存管理，提高了代码的安全性和可靠性，同时也减少了手动管理内存的负担，提升了程序的健壮性。 典型场景一个对象需要委派给工作线程（worker thread）来异步执行某项任务。在此期间，关键在于确保该对象在其生命周期内保持有效，避免在工作线程还在访问它的过程中已经析构。因为这将触发未定义行为，导致程序崩溃。 在设计异步处理逻辑时，一个常见且高效的实践是将该对象的weak_ptr作为参数传递给异步任务的闭包。在工作线程实际执行任务前，通过weak_ptr调用lock函数，可以安全地检查并尝试升级为shared_ptr，确保对象依然存活，有效避免了因为对象提前析构而导致的访问悬挂指针问题。 需要注意，使用weak_ptr可能会存在对象被析构之后，任务无法被执行。如果需要保证任务被执行，请使用shared_ptr。 一、继承enable_shared_from_this通过继承自enable_shared_from_this，我们的类能够在成员函数内部使用shared_from_this()方法，进而获得指向当前对象的共享指针。 12345678class Myclass : public std::enable_shared_from_this&lt;MyClass&gt; &#123;public:\tMyClass() = default;\tvoid process(); private:\tvoid process_w();&#125;; 123456789101112131415void MyClass::process () &#123;\t// get worker thread from thread pool\tauto workerThread = ThreadPool::Instance()-&gt;Get();\tstd::weak_ptr&lt;MyClass&gt; weakThis = shared_from_this();\tworkerThread-&gt;post([weakThis]&#123; // lock the weak pointer to check if &#x27;this&#x27; still exists auto sharedThis = weakThis.lock(); if (!sharedThis) return; sharedThis-&gt;process_w();\t&#125;);&#125;void MyClass::process_w() &#123;\t// process in worker thread...&#125; 二、构造工厂方法如果不想引入继承，我们可以选择设计一个工厂方法Create来实例化对象，此方法在生成对象实体的同时为成员变量mWeakThis赋值。为了进一步封装和确保安全，我们将MyClass的构造函数设为私有。 12345678910class Myclass : public std::enable_shared_from_this&lt;MyClass&gt; &#123;public:\tstatic std::shared_ptr&lt;MyClass&gt; Create();\tvoid process(); private: MyClass() = default;\tvoid process_w(); std::weak_ptr&lt;MyClass&gt; mWeakThis;&#125;; 1234567891011121314151617181920std::shared_ptr&lt;MyClass&gt; MyClass::Create() &#123;\tauto instance = std::shared_ptr&lt;MyClass&gt;(new MyClass());\tinstance-&gt;mWeakThis = instance;\treturn instance;&#125;void MyClass::process () &#123;\t// get worker thread from thread pool\tauto workerThread = ThreadPool::Instance()-&gt;Get();\tworkerThread-&gt;post([mWeakThis] &#123; // lock the weak pointer to check if &#x27;this&#x27; still exists auto sharedThis = mWeakThis.lock(); if (!sharedThis) return; sharedThis-&gt;process_w();\t&#125;);&#125;void MyClass::process_w() &#123;\t// process in worker thread...&#125;","tags":["C++"],"categories":["code"]},{"title":"sort使用不规范导致Crash问题","path":"/2024/06/16/code/sort使用不规范导致Crash问题/","content":"问题排查最近在使用std::sort进行排序的时候遇到一个crash问题，一开始摸不着头脑，花了一番功夫才找到原因。 背景是音视频通信的媒体服务端在和客户端建立媒体通道时，往往会有多条连接作为主备连接，应对不同网络情况，例如同时有5G、WIFI等多路连接。这些连接一般都是由客户端通过发送STUN协议的UDP包发起的。 当客户端建立的连接数超过限制时，服务端需要枝剪多余连接，枝剪的逻辑需要通过对比连接质量等一系列条件来排序决定。C++标准库已经为我们实现性能优异的std:sort，通常也没人会去挑战STL，这里我也直接就用了。代码片段如下： 123456789101112131415161718192021void P2PTransportChannel::PruneConnections2() &#123; std::map&lt;rtc_base::IPAddress, std::vector&lt;Connection*&gt;&gt; conns_map; //... insert map for (auto pair : conns_map) &#123; // sort connections std::sort(pair.second.begin(), pair.second.end(), [this](Connection* a, Connection* b) &#123; return CompareConnectionCandidates(a, b) &gt;= 0; &#125;); &#125;&#125; 这里sort传入一个闭包，闭包里调用CompareConnectionCandidates方法比较两条连接的优先级（因为两条连接可能优先级相等，所以用了&gt;&#x3D;，这也为后面的crash埋下了伏笔）。 代码乍一看好像没啥问题，上线前自测和QA测试也都正常。然而版本上线后，线上却出现了多例crash，coredump在了比较方法中，而且有个特点是connection连接数都比较多； 从crash堆栈看到参与比较的两个Connection指针a&#x3D;0x87a804feff3e1602，b&#x3D;0x4bc4a00，这里a的指针异常大： 1234567891011#0 0×00007f849b8cbbf1 in ice::P2PTransportChannel::CompareCandidatePairNetworks (ice::Connection const*, ice::Connection const*, rtc_base::optional&lt;rtc_base::AdapterType&gt;) const (this=0xd0c1400, a=0×87a804feffe1602, b=0x4bc4a00, network_pr eference=...) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1629#1 0x00007f849b8cbdab in ice::P2PTransportChannel::CompareConnectionCandidates (ice::Connection const*, ice::Connection const*) const (this=&lt;optimized cut &gt;, a=0x87a804feff3e1602, b=0x4bc4a00) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1731#2 0x00007f849b8cc0df in ice::P2PTransportChannel::&lt;lambda(ice::Connection *, ice::Connection*)&gt;::operator() (b=&lt;optimized out&gt;, a=&lt;optimized out&gt;, closure=&lt;synthetic pointer&gt;) at ../../../../core/pc/transport/ice/ice/p2p_transport_channel.cc:1996#3 0x007849b8ccodf in _gnu_cxx_opsTter_cop_itercdin_ice:PPTransportChannel::PruneConnections2()::&lt;lambda(ice::Connection*, ice::Connection*)&gt;&gt;::operator()&lt;_gnu_cxx::_normal_iteratorșice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;,_gnu_cxx::_normal_iterator&lt;ice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;&gt;(it2=0x4bc4a00, _it1=..., this=&lt;synthetic pointer&gt;) at /opt/rh/devtoolset-7/root/usr/include/c++/7/bits/predefined_ops.h:143#4 0×00007f849b8ccodf in std::_unguarded_partitions_gnu_cxx::_normal_iterator&lt;ice::Connection**, std::vector&lt;ice::Connection*&gt;&gt;,_gnu_cxx::_ops::_Iter_comp_iter&lt;ice::P2PTransportChannel::PruneConnections2()::&lt;lambda(ice::Connection*, ice::Connection*)&gt;&gt;&gt;(_comp=..., _pivot=0x4bc4a00, _last=0×87a804feff3e1602, _first=0x87a804feff3e1602) at /opt/rh/devtoolset-7/root/usr/include/c++/7/bits/stl_algo.h:1902 为了进一步确认，继续通过反汇编查看crash附近代码执行情况。可以看到崩溃行所在地方是从rsi访存写入rax寄存器，很可能是bad access了： 12345 0x00007f849b8cbbf0 &lt;+0&gt;: push %rbp=&gt; 0x00007f849b8cbbf1 &lt;+1&gt;: mov 0x150 (%rsi),%rax 继续查看内部寄存器状态： 123456789101112131415161718192021info register rax 0×0 0rbx 0x5f8cd78 100191608rcx 0×7f849e4b2db8 140207568137656rdx 0×4bc4a00 79448576rsi 0×87a804feff3e1602 -8671675589251426814rdi 0×d0c1400 218895360rbp 0×7f849e4b2de0 0×7f849e4b2de0 rsp 0×7f849e4b2da0 0×7f849e4b2da0 果然，rsi寄存器存放的Connection指针地址异常了。但是这里我们用的标准库进行遍历的，vector对象也在栈上，难道vector内部成员被篡改了？ 继续查看vector对象，一共17个成员，Connection指针地址也没有问题。难道是vector::end()返回的地址有问题？ 12345p pair.second $3 = std::vector of length 17, capacity 17=&#123;0×4bc4a00, 0xfb5de00, 0xf43c400, 0xf43a0, 0xef7400, xf43be00, 0xf3b000, xf43000, xf3bde00,0x1b800, xef73, fb5e400, 0xf3bf600, 0xf3bc600, 0x11b26000, 0xe18e000, 0x11b27e00&#125; 继续查看vector内部结构题__M_impl。其中__M_start指向容器中第一个元素的指针，__M_finish指向容器最后一个有效元素的下一个位置的指针，end()方法返回的就是__M_finish。 12345p pair.second._M_impl$2=&#123;&lt;std::allocator&lt;ice::Connection*&gt;&gt;=&#123;&lt;_gnu_cxx::new_allocator&lt;ice::Connection*&gt;&gt;=&#123;&lt;No data fields&gt;&#125;, &lt;No data fields&gt;&#125;, M_start =0x5f8ccf0, _M_finish =0x5f8cd78, _M_end_of_storage = 0x5f8cd78&#125; M_finish &#x3D; 0x5f8cd78，这个地址看起来也没问题。既然拿到了内存地址，我们可以进一步分析下里面存的到底是什么： 1234567891011121314151617181920212223242526272829303132333435x /8xg 0x5f8ccf00x5f8ccf0: 0x0000000004bc4a00 0x000000000fb5de000x5f8cd00: 0x000000000f43c400 0x000000000f43ac000x5f8cd10: 0x000000000ef74a00 0x000000000f43be000x5f8cd20: 0x000000000f3bc000 0X000000000f43a000` x /8xg 0x5f8cd300x5f8cd30: 0x000000000f3bde00 0x0000000011b278000x5f8cd40: 0x000000000ef73800 0x000000000fb5e4000x5f8cd50: 0x000000000f3bf600 0x000000000f3bc6000x5f8cd60: 0x0000000011626000 0x000000000e18e000 x /8xg 0x5f8cd700x5f8cd70: 0x0000000011b27e00 0x87a804feff3e16020x5f8cd80: 0x0000000005f8ce10 0x00000000000000000x5f8cd90: 0x0000000100000005 0x00000000000000010x5f8cda0: 0x0000000000000000 0x0000000100000005 这里我们用x&#x2F;8xg 查看内存地址。8代表要显示的内存单元数量，x表示16进制，g表示读取8字可以看到异常值0x87a804feff3e1602在内存地址0x5f8cd78处。这个地址对应__M_finish，是结束的地方，按道理sort排序不可能会访问到这个地址。但是出错的堆栈又实实在在指向了这个地址，一时间没有了思路。 std::sort实现没办法，只能尝试从源码入手，看看能不能有线索。通过分析代码和查阅资料，了解到gcc7的sort实现采用了混合排序，包含了插入排序、快速排序、桶排序三种排序算法，目的是为了综合各种排序算法的优点： 在数据量很大时采用正常的快速排序，此时效率为O（logN）。 一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O（N）。 在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O（N IogN），但这又比一开始使用堆排序好。 实现代码如下： 1234567891011121314151617181920212223template&lt;typename _RandomAccessIterator, typename _Compare&gt;inline void_sort(_RandomAccessIterator _first, _RandomAccessIterator _last, _Compare _comp)&#123; if (_first!= _last) &#123; std::_introsort_loop(_first, _last, _comp); // 内省式排序 std::lg(_last - _first) * 2; // 计算复杂度 std::_final_insertion_sort(_first, _last, _comp); // 插入排序 &#125;&#125; 这里是一个函数模版，包含了两个调用，std：introsort_loop是排序算法主体，std::final_insertion_sort则是插入排序； 先来看__introsort_loop： 12345678910111213141516171819202122232425262728293031323334353637template&lt;typename _RandomAccessIterator, typename _Size, typename _Compare&gt;void_introsort_loop(_RandomAccessIterator _first, _RandomAccessIterator _last, _Size _depth_limit, _Compare _comp)&#123; while (_last - _first &gt; int(_S_threshold))）// 数量大于_S_threshold（16），使用快速排序 &#123; if (_depth_limit == 0) &#123; std::_partial_sort(_first, _last, _last, _comp);// 深度&gt;0，使用桶排序 return; &#125; --_depth_limit; _RandomAccessIterator _cut = std::_unguarded_partition_pivot(_first, _last, _comp); _last = _cut; std::_introsort_loop(_cut, _last, _depth_limit, _comp); &#125;&#125; 注意只有当vector的数量超过__S_threshold（16）时，才会导致进入快速排序；否则，直接跳出循环（执行final__insertion_sort插入排序）。快速排序在while循坏体中，这里有一定的技巧性，调用unguarded__partition_pivot的返回值cut是pivot右半部分，之后再pivot左半部分继续调用introsort__loop，这样做可以减少函数调用次数。 接下来我们继续查看__unguarded_partition_pivot主体函数： 1234567891011121314151617template&lt;typename _RandomAccessIterator, typename _Compare&gt;inline _RandomAccessIterator_unguarded_partition_pivot(_RandomAccessIterator _first, _RandomAccessIterator _last, _Compare _comp)&#123; _RandomAccessIterator _mid = _first + (_last - _first) / 2; std::_move_median_to_first(_first, _first + 1, _mid, _last - 1, _comp); return std::_unguarded_partition(_first + 1, _last, _first, _comp);&#125; 主体分为两个方法，move_median_to_first的作用是从首部+1、尾部和中部三个元素的取中值作为pivot，避免可能出现快速排序的复杂度最差情况O（N？）。注意这里会调用comp比较函数进行比较和swap操作，把中间值交互到首部： 1234567891011121314151617181920212223242526272829303132333435363738394041template&lt;typename _Iterator, typename _Compare&gt;void_move_median_to_first(_Iterator _result, _Iterator _a, _Iterator _b, _Iterator _c, _Compare _comp)&#123; if (_comp(_a, _b)) &#123; if (_comp(_b, _c)) std::iter_swap(_result, _b); else if (_comp(_a, _c)) std::iter_swap(_result, _c); else std::iter_swap(_result, _a); &#125; else if (_comp(_a, _c)) std::iter_swap(_result, _c); else if (_comp(_b, _c)) std::iter_swap(_result, _b); else std::iter_swap(_result, _b);&#125; __unguarded_partition方法就是我们平常所使用的快速排序主体部分： 12345678910111213141516171819202122232425262728293031template&lt;typename _RandomAccessIterator, typename _Compare&gt;_RandomAccessIterator _unguarded_partition(_RandomAccessIterator _first, _RandomAccessIterator _last, _RandomAccessIterator _pivot, _Compare _comp)&#123; while (true) &#123; while (_comp(_first, _pivot)) ++_first; while (_comp(_pivot, _last)) --_last; if (!(_first &lt; _last)) return _first; std::iter_swap(_first, _last); ++_first; &#125;&#125; 这里不多做解释，《STL源码剖析》给出了两个非常直观的示意图： 分割示例一 分割示例二 方法名unguarded和代码里的while循环引起了我的警觉，这个函数没有对first和last作边界检查，而是以两个指针交错作为中止条件，节约了比较运算的开支。可以这么做的理由是因为，选择是首尾中间位置三个值的中间值作为pivot，因此一定会在超出此有效区域之前中止指针的移动（前提是comp条件不能相等）。 这里comp(first, pivot)如果是true，first会一直循环递增。我们的业务逻辑中，比较元素Connection是可能相等的。这里极有可能是first累加越界了，其地址也能和崩溃的地址对上。 如果是这个原因的话，我们就好验证了。写一段测试代码，放入大于__S_threshold（16）个相同元素，看看会不会崩溃。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; struct Connection &#123; int val = 0;&#125;; bool compare(Connection* a, Connection* b) &#123; return a-&gt;val &gt;= b-&gt;val;&#125; int main() &#123; std::map&lt;int, std::vector&lt;Connection*&gt;&gt; conn_map; for (int i = 0; i &lt; 17; i++) &#123; Connection* c = new Connection&#123;1&#125;; conn_map[1].push_back(c); &#125; for (auto&amp; pair : conn_map) &#123; std::sort(pair.second.begin(), pair.second.end(), compare); &#125; std::cout &lt;&lt; &quot;ok:&quot; &lt;&lt; conn_map[1].size() &lt;&lt; std::endl; return 0;&#125; 使用gcc7编译运行，果然出现崩溃了： 12345$./a. out2 Segmentation fault (core dumped) 而将17改为16之后，结果就不崩溃了： 12345$./a.out2 ok: 16 到这里，问题原因算是找到了。这也解释了为什么自测和QA难以发现，只有线上连接数多的时候才出现。回过头来查阅文档，上面写的很明白，sort的comp函数必须严格满足严格弱序（strict weak order）： 123456789Establishes strict weak ordering relation with the following properties:- For all a, comp(a, a) == false.- If comp(a, b) == true then comp(b, a) == false.- if comp(a, b) == true and comp(b, c) == true then comp(a, c) == true. 看来还是使用的姿势不对，修复就好办了，我们把判断条件中的&#x3D;去掉，这下也正常了： 12345$./a.out2 0k:17 总结 std::sort实现混合了多种排序算法，当元素数量超过16个，会使用快速排序，不会进行边界检查； std::sort的comp函数必须严格满足严格弱序，如果比较元素相等，可能会导致crash问题； 如果比较元素可能相等，想要结果保持稳定，使用std::stable_sort代替std::sort； 参考：https://feihu.me/blog/2014/sgi-std-sort/","tags":["C++"],"categories":["code"]},{"title":"macOS采集/录制系统音频数据","path":"/2021/02/22/code/macOS采集系统音频/","content":"PC端音视频相关应用往往会涉及到系统音频采集相关需求。例如音视频通信应用在屏幕共享场景下，用户除了共享屏幕内容之外，往往需要共享音频数据。目前macOS没有系统API可以直接获取输出到播放设备的音频数据，这就需要通过别的办法来采集系统音频。由于macOS开发相关资料较少，完成这个需求也花了点时间，在这里将思路做个分享，希望能帮助到有这方面需求的朋友。 技术背景macOS音频设备管理macOS支持管理多个音频输入输出设备，可以使用“音频 MIDI 设置”来设置如麦克风和多声道音频接口。 音频 MIDI 设置”界面如上图所示，左侧列表展示了所有音频输入输出设备，例如内建麦克风、扬声器、AirPods、通过数据线连接端iPhone设备，右侧界面支持调节设备端具体参数，例如音量等。 我们可以通过右键选择设备，将其设为系统默认的输入输出设备。设为默认设备后，设备列表上会有一个小图标显示，同时，系统会默认在对应的设备上采集、播放音频数据。当然，应用也依然可以选择特定设备采集、播放音频，例如Abode公司的Audition中可以通过设置选择输入输出设备。 switchaudio-osxswitchaudio-osx是一款开源项目，支持命令行设置macOS默认输入输出音频设备。这个开源项目为我们通过代码切换系统音频设备提供了极大帮助。 项目地址：https://github.com/deweller/switchaudio-osx KEXT内核扩展KEXT是macOS的内核扩展程序，通常用于系统驱动程序。内核扩展运行于内核态，支持动态加载。 我们可以在Xcode中选择“general kernel extension”创建内核扩展，基于IOKit接口实现驱动程序，生成的产物以kext作为后缀名。 加载驱动需要首先将kext文件拷贝到系统目录（需要管理员权限）： 1/Library/Extensions 加载驱动： 1sudo kextload /path/to/kext.kext 卸载驱动： 1sudo kextunload /path/to/kext.kext SoundflowerSoundflower是mac端开源的kext内核扩展程序，它虚拟了一套音频采集、播放设备驱动，直接将播放数据传给采集设备，实现音频数据环路。通过将系统默认输入输出设备设置为Soundflower，就可以采集到系统播放的音频数据。 项目地址：https://github.com/RogueAmoeba/Soundflower-Original Update(2021.6.9): 新发布的macOS11安全管理策略变得更为严格，由于kext运行在内核态，系统对其做了更多限制，不再建议使用。官方说明如下：macOS 中的系统和内核扩展 作为替代，建议使用基于CoreAudio框架实现的虚拟设备插件。CoreAudio插件运行在用户态，插件加载后，作用于Soundflower基本一致。 相关资料可以参考：Building an Audio Server Plug-in and Driver Extension 方案实现介绍完以上的技术背景，其实就可以设计出macOS系统音频数据采集方案： 如上图所示，用户App通过mac系统播放音频。 我们可以在启动系统音频采集功能时将系统音频播放设备设置为Soundflower虚拟扬声器，同时在App中将输入设为Soundflower虚拟麦克风和硬件麦克风，将混音后的音频数据输出到硬件扬声器。关闭系统音频采集功能将系统设置还原。理论上，这就已经可以满足我们的需求了。 关键调用流程为了实现以上方案，有以下关键调用流程： 第一次调用内录接口时，请求管理员权限，将Soundflower.kext内核扩展拷贝到系统目录 调用kextload命令加载Soundflower.kext 将系统默认音频播放设备设置为Soundflower虚拟扬声器 App中将音频采集设备设置为Soundflower虚拟麦克风 App中如果有硬件麦克风采集需求，则另起一路硬件麦克风采集 App中将音频播放设备设置为硬件扬声器 需要关闭该功能时，需要执行如下调用流程： 将系统默认输入输出设备还原 卸载Soundflower.kext 以上调用流程并不复杂，关键代码都可以从以上介绍的开源项目中找到参考，需要注意一下几点： 加载&#x2F;卸载kext需要系统提权，macOS提权可以选择AuthorizationRef或者苹果官方推荐的SMJobBless 切换系统默认音频设备代码实现可以参考switchaudio-osx项目中audio_switch.c相关代码 至于mac端音频采集播放的代码实现就相对比较复杂了，不过幸运的是，谷歌WebRTC项目中audio_device_mac.cc已经有了一套实现 总结文本提供了macOS采集&#x2F;录制系统音频数据的一种实现思路。具体代码实现过程中，还是有很多工作需要做的，例如系统提权如果要做的比较友好就需要用到SMJobBless启动守护进程来实现。当然，这属于另外一个话题了，在此不再赘述。","tags":["AV"],"categories":["code"]},{"title":"生命以负熵为食","path":"/2020/03/14/text/生命以负熵为食/","content":"生命以负熵为食1944年，薛定谔在他的著作《生命是什么》中首次提出了天才般的发现 ——“生命以负熵为食”。这一发现，从宇宙规律角度解释了生命遗传与演化的奥秘，这也揭示了学习的重要性。 你可能会问，负熵是啥，我可没吃过这玩意儿，它和学习又有啥关系呢？别急，下面我们就来详细解释这句话的含义。 首先，我们要理解熵的概念。熵是热力学中表征物体状态的重要概念，其物理意义是一个系统的混乱程度。换言之，一个系统越混乱、随机性越高，其熵就越高；反之，熵就越低。对应的，我们还可以推广出负熵的概念，它的物理意义是系统的秩序化、组织化程度。 著名的热力学第二定律又叫熵增定律，它告诉我们：孤立系统永远朝着熵增的状态发展。也就是说，任何一个系统，只要没有外界能量的输入，总是会朝着无序化发展。 例如，我们的宇宙就可以看作一个孤立系统，它无时无刻都在膨胀，终有一天将归于无序的混沌之中，科学家将这种状态称为热寂（Heat death）。 熵增定律是宇宙的基本定律，它不但揭示了宇宙的终极命运，也同样适用于宇宙中任何事物，包括我们自身。 从熵的角度看，生命的本质是负熵。因为生命的形式就是有序的，生命存在的过程就是不断利用从外界吸取的能量，维持自身的有序性，用以对抗宇宙无序化的过程。 我们的皮肤、血肉与筋骨组成了人体结构。人体之所以能保持这种精致的有序性，是因为我们每天吃饭，从环境种摄入能量（高级负熵），排出产生的废物（低级负熵）。而人没有了输入能量，这副皮囊就会逐渐腐朽，最终化为尘埃，回到无序状态。 所以用高级和低级来形容负熵，是想说明负熵是有能量高低的。比如对于人类来说，我们每天吃的肉就是一种高级负熵，消化后产生的粑粑是一种废料。但对青菜来说，粑粑却是肥料。用这个眼光再来看，生机勃勃的自然界只是表象，它的本质是一个负熵的能量循环。 也就解释了“生命以负熵为食“这句话的涵义。 信息就是负熵讲到这里其实只解释了一半，因为我们只是从能量的角度了解了薛定谔这句话的生物学意义。但它还有一个另一层更为深远的意义，直指生命本质。 在解释这一层意义之前，我们需要介绍另外一位科学家，他叫克劳德 香农，是信息论的创始人。 1948年，发生了一件影响深远的事件。在那一年，香农发表了著名的专题论文 ——《通信的数学原理》。在这个标题简洁但内容宏大的论文中，香农完成了信息论的构建。他借用热力学中熵的概念，提出一个重要的观点： 信息就是负熵。 听上去有些费解，那我们不妨从日常生活的角度来理解。我们身边到处都是信息：市场上猪肉的价格是信息，电视上发生的新闻是信息，甚至明星的八卦也是信息。 信息本身没有意义，他的意义体现在获取信息的人所做出的决策中。例如，你提前知道了某个公司的重大收购信息，就可以在股市上大赚一笔。再比如，你从天气预报中知道了今天会下雨这一信息，就可能取消原来计划的行程，避免了一次不愉快的旅行。 更多时候，信息并不能直接指导我们的决策，而是需要我们推理之后才能得出结论。比如你要开一家门店，就要做好充分的市场调研，获取客户喜好、客流量等信息后，需要综合分析才能做出决定。 当然，信息不能等同于事实，区分信息正确与否才能做出正确的决策。战场上，如果收到了敌人伪造的信息，可能会导致损失惨重。 总而言之，信息能影响我们如何决策。从生物学的角度看，生物体做决策的根本目的是为了生存繁衍，也就是保证自身（及其基因延续）的有序性。这和生物获取食物的目的是一致的！从这个意义上讲，信息就是负熵。 学习与本能“信息就是负熵”这一发现，为“生命以负熵为食”注入了更为深刻的内涵。它让我们意识到，信息就和食物一样，是生命必不可少的资源。甚至，信息的对生物体的重要程度远远超越了食物。 没有了食物，可能只会挨一顿饿，但是没有掌握信息，可能意味着生命的死亡。 我们为什么看到蛇本能的就害怕呢？这是我们的DNA记录着害怕蛇的基因，那些不害怕蛇的祖先早就中毒身亡了。基因是祖先为我们记录和传递的信息，刚开始你可能很难认识到这一点，一旦理解了之后就会感叹大自然的神奇。 是的，在语言与文字发明之前，大自然进化出的一套缓慢而又神奇的信息传递机制——演化。这套机制的核心原理是通过基因突变，制造微小的信息差异，在亿万年的时间尺度下、无数代生物个体组成的巨大样本中，筛选出适合生存的信息，通过DNA结构完成信息的保存和传递。 自然演化虽然如此巧妙，但是却十分缓慢。而且，在这个机制下的个体生命只是整个信息筛选中一个微不足道的成员变量，充满了随机性。难道人类只能和虫子一样通过大量复制，保证种群的延续吗？ 所幸，人类还发明了语言和文字。它们的出现，不仅是一种信息记录与传递的新手段，更是一次历史性的革新。从此，人类记录信息的方式不仅仅是靠DNA携带那几百兆的信息量，而是有了一种更为高效且无限容量的方式——学习。 让我们对人类害怕蛇的本能再做一次延伸。比如，小孩子并不知道触摸电路板是一件危险的事情，因为人类的还没有进化出害怕电路板的本能。如果依靠演化机制，人类可能需要几百万年的时间，牺牲无数个体之后才能筛选出特定基因，从而把害怕电路板变为本能。而有了学习，每个人都能很快做出正确的决策，保证个体生命的有序性。 可见，学习是远比演化更为高效的信息传递的方式。也正是因为学习，人类才能迅速从所有生物中脱颖而出，实现了文明的巨大飞跃。 学习与演化我们现在知道了学习的高效，再看自然演化机制，不免显得笨拙可笑。真的是这样吗？ 从一个更大的视角看，也许学习本身也是一种演化方式。 从这个意义上讲，人类从分娩的那一刻起，并没有真正完成生命的演进。 因为我们的生存所需遗传信息，除了记录在DNA中，还存在于书本里。 而学习，就是在宏观层面复现DNA的复制与转录。","tags":["信息"],"categories":["text"]},{"title":"mp4文件格式重点解析","path":"/2019/04/03/code/MP4文件格式重点解析/","content":"简介mp4文件格式又被称为MPEG-4 Part 14，出自MPEG-4标准第14部分 。它是一种多媒体格式容器，广泛用于包装视频和音频数据流、海报、字幕和元数据等。（顺便一提，目前流行的视频编码格式AVC&#x2F;H264定义在MPEG-4 Part 10）。mp4文件格式基于Apple公司的QuickTime格式，因此，QuickTime File Format Specification 也可以作为我们研究mp4的重要参考。 mp4文件由box组成，每个box分为Header和Data。其中Header部分包含了box的类型和大小，Data包含了子box或者数据，box可以嵌套子box。下图是一个典型mp4文件的基本结构：图中看到mp4文件由几个主要组成部分： ftypFile Type Box，一般在文件的开始位置，描述的文件的版本、兼容协议等。 moovMovie Box，包含本文件中所有媒体数据的宏观描述信息以及每路媒体轨道的具体信息。一般位于ftyp之后，也有的视频放在文件末尾。注意，当改变moov位置时，内部一些值需要重新计算。 mdatMedia Data Box，存放具体的媒体数据。 Moov结构解析mp4的媒体数据信息主要存放在Moov Box中，是我们需要分析的重点。moov的主要组成部分如下： mvhdMovie Header Box，记录整个媒体文件的描述信息，如创建时间、修改时间、时间度量标尺、可播放时长等。 下图示例中，可以获取文件信息如时长为3.637秒。 udtaUser Data Box，自定义数据。 trackTrack Box，记录媒体流信息，文件中可以存在一个或多个track，它们之间是相互独立的。每个track包含以下几个组成部分： tkhdTrack Header Box，包含关于媒体流的头信息。 下图示例中，可以看到流信息如视频流宽度720，长度1280。 mdiaMedia Box，这是一个包含track媒体数据信息的container box。子box包括：mdhd：Media Header Box，存放视频流创建时间，长度等信息。hdlr：Handler Reference Box，媒体的播放过程信息。minf：Media Information Box，解释track媒体数据的handler-specific信息。minf同样是个container box，其内部需要关注的内容是stbl，这也是moov中最复杂的部分。stbl包含了媒体流每一个sample在文件中的offset，pts，duration等信息。想要播放一个mp4文件，必须根据stbl正确找到每个sample并送给解码器。mdia展开如下图所示： Stbl 结构解析Sample Table Box，上文提到mdia中最主要的部分是存放文件中每个sample信息的stbl。在解析stbl前，我们需要区分chunk和sample这两个概念。在mp4文件中，sample是一个媒体流的基本单元，例如视频流的一个sample代表实际的nal数据。chunk是数据存储的基本单位，它是一系列sample数据的集合，一个chunk中可以包含一个或多的sample。stbl用来描述每个sample的信息，包含以下几个主要的子box： stsdSample Description Box，存放解码必须的描述信息。 下图示例中，对于h264的视频流，其具体类型为avc1，extensions中其中存放有sps，pps等解码必要信息。 sttsTime-to-Sample Box，定义每个sample时长。Time-To-Sample的table entry布局如下：sample count：sample个数sample duration：sample持续时间持续时间相同的连续sample可以放到一个entry里达到节省空间的目的。 下图示例中，第1个sample时间为33362微秒，第2-11个sample时间为33363微秒： stssSync Sample Box，同步sample表，存放关键帧列表，关键帧是为了支持随机访问。stss的table entry布局如下：下图示例中，该视频track只有一个关键帧即第1帧： stscSample-To-Chunk Box，sample-chunk映射表。上文提到mp4通常把sample封装到chunk中，一个chunk可能会包含一个或者几个sample。Sample-To-Chunk Atom的table entry布局如下图所示： First chunk：使用该表项的第一个chunk序号Samples per chunk：使用该表项的chunk中包含有几个sampleSample description ID：使用该表项的chunk参考的stsd表项序号 下图示例中，可以看到该视频track一共有两个stsc表项，chunk序列1-108，每个chunk包含一个sample，chunk序列109开始，每个chunk包含两个sample。 stszSample Size Box，指定了每个sample的size。Sample Size Atom包含两sample总数和一张包含了每个sample size的表。sample size 表的entry布局如下图： 下图示例中，该视频流一共有110个sample，第1个sample大小为42072字节，第2个sample大小为7354个字节。 stcoChunk Offset Box，指定了每个chunk在文件中的位置，这个表是确定每个sample在文件中位置的关键。该表包含了chunk个数和一个包含每个chunk在文件中偏移位置的表。每个表项的内存布局如下： 需要注意，这里stco只是指定的每个chunk在文件中的偏移位置，并没有给出每个sample在文件中的偏移。想要获得每个sample的偏移位置，需要结合 Sample Size box和Sample-To-Chunk 计算后取得。 下图示例中，该视频流第1个chunk在文件中的偏移为4750，第1个chunk在文件中的偏移为47007。 如何计算sample偏移位置上文提到通过stco并不能直接获取某个sample的偏移位置，下面举例说明如何获取某一个pts对应的sample在文件中的位置。大体需要以下步骤： 1.将pts转换到媒体对应的时间坐标系 2.根据stts计算某个pts对应的sample序号 3.根据stsc计算sample序号存放在哪个chunk中 4.根据stco获取对应chunk在文件中的偏移位置 5.根据stsz获取sample在chunk内的偏移位置并加上第4步获取的偏移，计算出sample在文件中的偏移 例如，想要获取3.64秒视频sample数据在文件中的位置： 1.根据time scale参数，将3.64秒转换为视频时间轴对应的3640000 2.遍历累加下表所示stts所有项目，计算得到3640000位于第110个sample 123456type\tsttssize\t224flags\t0version\t0sample_counts\t1,10,1,1,11,1,1,2,1,25,1,1,1,17,1,10,1,1,1,7,1,1,1,1,10,1sample_deltas\t33362,33363,33362,33364,33363,33362,33364,33363,33362,33363,33362,33364,33362,33363,33362,33363,33362,33364,33362,33363,33362,33364,33363,33362,33363,0 3.查询下表所示stsc所有项目，计算得到第110个sample位于第109个chunk，并且在该chunk中位于第2个sample 1234567type\tstscsize\t40flags\t0version\t0first_chunk\t1,109samples_per_chunk\t1,2sample_description_index\t1,1 4.查询下表所示stco所有项目，得到第109个chunk在文件中偏移位置为1710064 123456Property name\tProperty valuetype\tstcosize\t452flags\t0version\t0chunk_offsets\t4750,47007,54865,61967,75519,88424,105222,117892,133730,149529,165568,182034,194595,210776,225470,240756,255358,270711,285459,300135,315217,330899,347372,363196,376409,394509,407767,424615,438037,455603,469784,487287,505197,519638,536714,553893,567187,584744,599907,615298,630669,645918,662605,678655,693510,708980,724061,738946,754170,771520,787233,800847,816997,832490,847814,862559,877929,898379,911054,925810,943883,956497,974403,991527,1009478,1025198,1041806,1062609,1078401,1091360,1105142,1118748,1132815,1145281,1156966,1171871,1186742,1202760,1218235,1236688,1249330,1263163,1280880,1297903,1313162,1332885,1345726,1359017,1376283,1391401,1405512,1419550,1433644,1452103,1475241,1492689,1511291,1522606,1535368,1559413,1575331,1588853,1609829,1626623,1642798,1658640,1674160,1693972,1710064 5.查询下表所示stsz所有项目，得到第109个sample的size为14808。计算得到3.64秒视频sample数据在文件中offset：1710064+14808 &#x3D; 1724872size：17930 1234567type\tstszsize\t460flags\t0version\t0sample_sizes\t42072,7354,6858,13110,12684,16416,12490,15497,15630,15865,16116,12387,15775,14519,14929,14433,15181,14390,14496,14717,15507,16101,15643,12843,17911,13070,16455,13221,17186,14002,17139,17737,14251,16708,16999,12911,17356,14801,15213,15016,15062,16505,15689,14657,15053,14907,14527,15048,17161,15308,13432,15777,15307,14971,14568,14987,20264,12494,14382,17873,12235,17718,16770,17766,15366,16420,20623,15403,12761,13394,13390,13714,12295,11505,14541,14689,15635,15291,18091,12458,13645,17346,16847,14902,19530,12446,13105,16872,14937,13944,13657,13908,18092,22959,17080,18421,11129,12400,23844,15564,13340,20603,16609,15984,15474,15339,19451,15719,14808,17930sample_size\t0sample_count\t110 验证：用编辑器打开mp4文件，定位到文件偏移1724872位置，前4字节值为0x00004606。在avcc中一个sample的前4个字节代表这个包的大小，转换为十进制是17926，正好等于17930减去四个长度字节。 参考资料在线mp4解析工具QuickTime File Format Specification","tags":["AV"],"categories":["code"]},{"title":"iOS实现Crash捕获与堆栈符号化","path":"/2018/08/30/code/iOS实现Crash捕获与堆栈符号化/","content":"在应用程序开发过程中，最棘手的问题莫过于crash。已经上线的crash无法看到崩溃现场，只能通过crash日志进行定位分析。通常情况下，可以使用苹果自带的crash log或者第三方的crash组件进行crash捕获。但是在一些场景下，需要我们手动实现crash捕获与符号化，比如开发SDK。 Crash捕获iOS端的crash分为两类，一类是NSException异常，另外一类是Signal信号异常。这两类异常我们都可以通过注册相关函数来捕获，但是值得注意的是一个应用中如果注册了多个crash收集组件，必然会存在冲突问题。这个时候，我们需要在注册之前判断是否已经注册过handler，如果有注册过，需要把之前注册的handler函数指针保存，待处理完crash后，再把对应的handler抛出去。 1. NSException异常捕获NSException异常是OC代码导致的crash，我们可以先调用NSGetUncaughtExceptionHandler获取之前注册的handler，如果有就保存起来，再通过NSSetUncaughtExceptionHandler方法注册自己的handler： 123456void RegisterExceptionHandler() &#123; if(NSGetUncaughtExceptionHandler() != MyExceptionHandler) &#123; OldHandler = NSGetUncaughtExceptionHandler(); &#125; NSSetUncaughtExceptionHandler(&amp;MyExceptionHandler);&#125; 处理完成后再调用保存的handler，抛出异常： 12345678910void MyExceptionHandler(NSException *exception) &#123; // do something... // 调用之前已经注册的handler if(OldHandler) &#123; OldHandler(exception); &#125;&#125; 2. Signal信号捕获Signal信号是由iOS底层mach信号异常转换后以signal信号抛出的异常。既然是兼容posix标准的异常，我们同样可以通过sigaction函数注册对应的信号。因为signal信号有很多，有些信号在iOS应用中也不会产生，我们只需要注册常见的几类信号： 12345SIGILL\t4\t非法指令 执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号.SIGABRT\t6\t调用abort 程序自己发现错误并调用abort时产生,一些C库函数中，如strlenSIGSFPE\t8\t浮点运算错误 如除0操作SIGSEGV\t11\t段非法错误 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据,空指针，数组越界，栈溢出等 下面我们注册一个SIGABRT信号，在注册handler之前，需要保存之前注册的hander: 123456789101112131415161718void RegisterSignalHandler() &#123; struct sigaction old_action; sigaction(SIGABRT, NULL, &amp;old_action); if (old_action.sa_flags &amp; SA_SIGINFO) &#123; SignalHandlerFunc handler = (SignalHandlerFunc)old_action.sa_sigaction; if (handler != MySignalHandler) &#123; // 保存OldAbrtSignalHandler OldAbrtSignalHandler = handler; &#125; &#125; // 注册MySignalHandler struct sigaction action; action.sa_sigaction = MySignalHandler; action.sa_flags = SA_NODEFER | SA_SIGINFO; sigemptyset(&amp;action.sa_mask); sigaction(signal, &amp;action, 0);&#125; 处理完成后，同样抛出handler: 1234567891011static void MySignalHandler(int signal, siginfo_t* info, void* context) &#123; // do something... // 处理前者注册的 handler if (signal == SIGABRT) &#123; if (OldAbrtSignalHandler) &#123; OldAbrtSignalHandler(signal, info, context); &#125; &#125;&#125; 收集调用堆栈调用堆栈的收集我们可以利用系统api，也可以参考PLCrashRepoter等第三方实现获取所有线程堆栈。使用系统api关键代码如下: 1234567NSMutableString *text = [NSMutableString string]; void* callstack[128]; int i, frames = backtrace(callstack, 128); char** strs = backtrace_symbols(callstack, frames); for (i = 0; i &lt; frames; ++i) &#123; [text appendFormat:@&quot;%@ &quot;, [NSString stringWithCString:strs[i] encoding:NSUTF8StringEncoding]]; &#125; 堆栈符号化通过系统api获取的堆栈信息可能只是一串内存地址，很难从中获取有用的信息协助排查问题，因此，需要对堆栈信息符号化。符号化的思路是找到当前应用对于的dsym符号表文件，利用dwarfdump，atos等工具还原crash堆栈内存地址对应的符号名。需要注意如果应用中使用了自己或第三方的动态库，应用崩溃在动态库Image而不是主程序Image中，我们需要有对应动态库的dsym符号表才能符号化。思路明确之后，接下来面临的是两个问题。一个问题是如何把当前crash的应用和dsym符号表对应上。另一个问题是如何通过内存地址符号化。在解决这两个问题之前，我们需要先了解可执行文件的二进制格式和加载过程。 1. Mach-O文件格式不同操作系统都会定义不同的可执行文件格式。如Linux平台的ELF格式，Windows平台的PE格式，iOS的可执行文件格式被称作Mach-O。可执行文件，动态库，dsym文件都是这种文件格式。下图是官方的Mach-O格式结构：可以看到，Mach-O文件分为三部分。第一部分是header，hander定义了文件的基本信息，包括文件大小，文件类型，使用的平台等信息。我们可以从loader.h头文件中找到相关定义： 123456789101112131415/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; 其次是load commands，这一部分定义了详细的加载指令，指明如何加载到内存。从头文件定义可以看到，基础的load_command结构体只包含了cmd以及cmdsize，通过cmd类型，可以转义成不同类型的load command 结构体： 1234struct load_command &#123;\tuint32_t cmd; /* type of load command */\tuint32_t cmdsize;\t/* total size of command in bytes */&#125;; 最后的数据部分，包括了代码段，数据段，符号表等具体的二进制数据。我们可以用otool查看二进制文件的具体内容，更直观的，可以用Mach-O View来浏览可执行文件的具体内容。下图是一个可执行文件与其所对于的符号表文件。可执行文件的load command比较多，里面包含了有代码段，数据段，函数入口，加载动态库等指令。其中的LC_UUID字段和符号表中的LC_UUID是完全对应的，也就是说，可以通过UUID字段匹配可执行文件和dsym符号表。 2. 可执行文件加载过程一个iOS应用的加载过程是这样的，首先，由内核加载可执行文件（Mach-O），并从中获得dyld的路径。然后加载dyld，由dyld接管动态库加载，符号绑定等工作，runtime的初始化工作也在这一阶段进行。最后dyld调用main函数，这样便来到了main函数入口。在这个过程中，操作系统为了安全考虑，使用了ASLR技术。地址空间布局随机化(Address space layout randomization)，就是每次应用加载时，使用随机的一个地址空间,这样能有效防止被攻击。VM Address是编译后Image的起始位置，Load Address是在运行时加载到虚拟内存的起始位置，Slide是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同，有下面公式： 1Load Address = VM Address + Slide 由于dsym符号表是编译时生成的地址，crash堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。 crash日志里的符号地址被称为Stack Address，而编译后的符号地址被称为Symbol Address，他们之间的关系如下： 1Stack Address = Symbol Address + Slide 符号化就是通过Symbol Address到dsym文件中寻找对应符号信息的过程。 3. 获取Binary Images信息我们在demo的viewDidLoad方法中调用abort方法制造一个crash。仔细观察一下系统采集到的crash日志，报错地址Stack Address位于0x1046eea14，相对Load Address 0x1046e8000偏移了27156。这里的27156并不是ASLR的随机偏移Slide，而是符号相对位置offset(Symbol Address - VM Address)：再观察crash日志最后，有一栏Binary Images，记录了所有加载image的UUID和加载的Load Address：根据前文提到的UUID对应关系以及Load Address和Symbol Address的转换关系，只要能获取Binary Images信息，就可以实现符号化。UUID存放在Mach-O的load command中，对应uuid_command结构体的uuid字段，可以通过遍历所有load command获取。Slide偏移可以通过image_dyld_get_image_vmaddr_slide方法遍历所有Image获取。VM Address也存放在load command中，对应segment_command结构体的vmaddr字段，需要注意segment_command存在多种类型以及需要区分32位和64位应用的细微差别。解析代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) &#123; uint64_t vmbase = 0; uint64_t vmslide = 0; uint64_t vmsize = 0; uint64_t loadAddress = 0; uint64_t loadEndAddress = 0; NSString *imageName = @&quot;&quot;; NSString *uuid; const struct mach_header *header = _dyld_get_image_header(i); const char *name = _dyld_get_image_name(i); vmslide = (i); imageName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding]; BOOL is64bit = header-&gt;magic == MH_MAGIC_64 || header-&gt;magic == MH_CIGAM_64; uintptr_t cursor = (uintptr_t)header + (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header)); struct load_command *loadCommand = NULL; for (uint32_t i = 0; i &lt; header-&gt;ncmds; i++, cursor += loadCommand-&gt;cmdsize) &#123; loadCommand = (struct load_command *)cursor; if(loadCommand-&gt;cmd == LC_SEGMENT) &#123; const struct segment_command* segmentCommand = (struct segment_command*)loadCommand; if (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == 0) &#123; vmsize = segmentCommand-&gt;vmsize; vmbase = segmentCommand-&gt;vmaddr; &#125; &#125; else if(loadCommand-&gt;cmd == LC_SEGMENT_64) &#123; const struct segment_command_64* segmentCommand = (struct segment_command_64*)loadCommand; if (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == 0) &#123; vmsize = segmentCommand-&gt;vmsize; vmbase = (uintptr_t)(segmentCommand-&gt;vmaddr); &#125; &#125; else if (loadCommand-&gt;cmd == LC_UUID) &#123; const struct uuid_command *uuidCommand = (const struct uuid_command *)loadCommand; NSString *uuidString = [[[NSUUID alloc] initWithUUIDBytes:uuidCommand-&gt;uuid] UUIDString]; uuid = [[uuidString stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;] lowercaseString]; &#125; &#125; loadAddress = vmbase + vmslide; loadEndAddress = loadAddress + vmsize - 1; &#125; // do something... 4. 符号化通过上述代码，我们可以采集到和系统一样的crash日志。接下来，可以使用dwarfdump和atos进行符号化。 4.1 dwarfdump拿到crash日志后，我们要先确定dsym文件是否匹配。可以使用dwarfdump –uuid命令查看dsym文件所有架构的UUID: 123$ dwarfdump --uuid mytest.app.dSYM UUID: B4217D5B-0349-3D9F-9D70-BC7DD60DA121 (armv7) mytest.app.dSYM/Contents/Resources/DWARF/mytestUUID: A52E3452-C2EF-3291-AE37-9392EDCCE572 (arm64) mytest.app.dSYM/Contents/Resources/DWARF/mytest 可以看到dsym文件的arm64架构中包含的A52E3452-C2EF-3291-AE37-9392EDCCE572和Binary Images中的UUID是相匹配的。下面就可以用dwarfdump –lookup命令对报错堆栈符号化，格式如下： 1dwarfdump --arch [arch type] --lookup [Symbol Address] [dsym file path] 对于报错堆栈的Stack Address 0x1046eea14，需要进行一个转换。已知VM Address为0x100000000，Load Address为0x1046e8000，可以得到Slide为0x46e8000。通过公式Symbol Address &#x3D; Stack Address - Slider求得Symbol Address为0x100006a14，输入命令： 123456789101112131415161718192021222324252627282930313233$ dwarfdump --arch arm64 --lookup 0x100006a14 mytest.app.dSYM ---------------------------------------------------------------------- File: mytest.app.dSYM/Contents/Resources/DWARF/mytest (arm64)----------------------------------------------------------------------Looking up address: 0x0000000100006a14 in .debug_info... found!0x0003ebb7: Compile Unit: length = 0x000000d4 version = 0x0004 abbr_offset = 0x00000000 addr_size = 0x08 (next CU at 0x0003ec8f)0x0003ebc2: TAG_compile_unit [120] * AT_producer( &quot;Apple LLVM version 9.1.0 (clang-902.0.39.2)&quot; ) AT_language( DW_LANG_ObjC ) AT_name( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; ) AT_stmt_list( 0x00009151 ) AT_comp_dir( &quot;/Users/worthyzhang/Desktop/mytest&quot; ) AT_APPLE_optimized( true ) AT_APPLE_major_runtime_vers( 0x02 ) AT_low_pc( 0x00000001000069bc ) AT_high_pc( 0x000000a4 )0x0003ebf9: TAG_subprogram [122] * AT_low_pc( 0x00000001000069bc ) AT_high_pc( 0x00000070 ) AT_frame_base( reg29 ) AT_object_pointer( &#123;0x0003ec12&#125; ) AT_name( &quot;-[ViewController viewDidLoad]&quot; ) AT_decl_file( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; ) AT_decl_line( 17 ) AT_prototyped( true ) AT_APPLE_optimized( true )Line table dir : &#x27;/Users/worthyzhang/Desktop/mytest/mytest&#x27;Line table file: &#x27;ViewController.m&#x27; line 25, column 1 with start address 0x0000000100006a14Looking up address: 0x0000000100006a14 in .debug_frame... not found.mp 可以定位到报错所在的函数名[ViewController viewDidLoad]以及文件名，行号等信息。 4.2 atos如果只是简单的获取符号名，可以用atos来符号化，命令格式如下： 1atos -o [dsym file path] -l [Load Address] -arch [arch type] [Stack Address] 需要注意这里的dsym file path是dsym文件而不是.dSYM结尾的文件夹，输入命令： 12$ atos -o mytest.app.dSYM/Contents/Resources/DWARF/mytest -l 0x1046e8000 --arch arm64 0x1046eea14-[ViewController viewDidLoad] (in mytest) (ViewController.m:25) 得到结果和dwarfdump是一致的。 参考资料：Mach-O ExecutablesMach-O Programming Topics漫谈iOS Crash收集框架iOS崩溃堆栈信息的符号化解析","tags":["iOS"],"categories":["code"]},{"title":"404 Not Found：该页无法显示","path":"//404.html","content":""},{"title":"关于","path":"/about/index.html","content":"程序员"}]